#########################################################################
##   This file is part of the α,β-CROWN (alpha-beta-CROWN) verifier    ##
##                                                                     ##
##   Copyright (C) 2021-2025 The α,β-CROWN Team                        ##
##   Team leaders:                                                     ##
##          Faculty:   Huan Zhang <huan@huan-zhang.com> (UIUC)         ##
##          Student:   Xiangru Zhong <xiangru4@illinois.edu> (UIUC)    ##
##                                                                     ##
##   See CONTRIBUTORS for all current and past developers in the team. ##
##                                                                     ##
##     This program is licensed under the BSD 3-Clause License,        ##
##        contained in the LICENCE file in this directory.             ##
##                                                                     ##
#########################################################################

import multiprocessing
import os
import time
import copy
from collections import defaultdict

import torch

import arguments
from lp_mip_solver import CPLEX_FOLDER, construct_mip_with_model
from cuts.cut_utils import generate_cplex_cuts
from cuts.cutter import Cutter

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from beta_CROWN_solver import LiRPANet


def cut_verification(net, domains):
    cut_args = arguments.Config['bab']['cut']
    lp_cut_enabled = cut_args['lp_cut']
    cplex_cuts = cut_args['cplex_cuts']
    cplex_cuts_wait = cut_args['cplex_cuts_wait']

    print('======================Cut verification begins======================')
    start_cut = time.time()
    # enable lp solver
    if lp_cut_enabled:
        net.build_the_model_lp()
    if cplex_cuts:
        time.sleep(cplex_cuts_wait)
        generate_cplex_cuts(net)
    if len(domains) >= 1 and getattr(net.cutter, 'opt', False):
        # beta will be reused from split_history
        assert len(domains) == 1
        assert isinstance(domains[0].split_history['general_betas'], torch.Tensor)
        net.cutter.refine_cuts(split_history=domains[0].split_history)
    # If the cut is constructed, we will have a cut module in the beginning.
    if net.cutter.cuts is not None:
        cut_module = net.cutter.construct_cut_module()
        net.net.cut_module = cut_module
        for m in net.net.relus:
            m.cut_module = cut_module
    print('Cut time:', time.time() - start_cut)
    print('======================Cut verification ends======================')


def set_cuts(self: 'LiRPANet'):
    assert self.cutter is not None, "Cutter should be created in incomplete verification."
    
    cuts = None
    if arguments.Config["bab"]["cut"]["manual_cuts"] is not None:
        # feed manual cuts
        from cuts.cut_utils import read_cut
        filename = arguments.Config['bab']['cut']['manual_cuts']
        print(f"read customized cut file {filename}")
        try:
            # The indicated cut may be text contents of the cut file.
            # First try to load the cut file as a text file.
            # This is for the case you want to use the cut file as a text file.
            # e.g. saved cut in dictionaly format.
            cuts = read_cut(filename + '.cuts')
        except UnicodeDecodeError as e:
            # Then use to read the cut file as a binary file.
            # e.g. cuts generated from CPLEX cpp version.
            # Usually, the cut file is generated by CPLEX and saved in binary format.
            # with xxx.cuts as cuts and xxx.indx as var_names.
            print(f"UnicodeDecodeError: {e}. The file may contain non-ASCII characters.")
            try:
                from cuts.cut_utils import parse_cplex_indx, parse_cplex_cuts
                var_names = parse_cplex_indx(filename + '.indx')
                self.net.var_names = var_names
                relu_layer_names = [relu_layer.name for relu_layer in self.net.relus]
                pre_relu_layer_names = [relu_layer.inputs[0].name for relu_layer in self.net.relus]
                cuts, _ = parse_cplex_cuts(filename + '.cuts', self.net.var_names, relu_layer_names, pre_relu_layer_names)
            except FileNotFoundError:
                print(f"Error: The file {filename} was not found.")
                raise Exception(f"Cannot read cut file {filename}")
        print(f'{len(cuts)} customized cuts loaded')
        cuts = cuts[:arguments.Config["bab"]["cut"]["number_cuts"]]
        print(f'{len(cuts)} customized cuts used')
        self.cutter.cuts = cuts
        cut_module = self.cutter.construct_cut_module()
        self.net.cut_module = cut_module
        for m in self.net.relus:
            m.cut_module = cut_module

    if cuts is None and not (arguments.Config["bab"]["cut"]["cplex_cuts"] or arguments.Config["bab"]["cut"]['biccos']["enabled"]):
        print("Warning: Cuts should either be automatically generated by cplex or manually given by --manual_cuts")
        exit()


def create_mip_building_proc(self: 'LiRPANet', x):
    # throw error if "get_cuts" executable does not exist
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)
    if not is_exe(f'{CPLEX_FOLDER}/get_cuts'):
        raise Exception(f"CPLEX cutting planes are needed.\n"
                        f"However, the executable for generating them is not found, which should be in path '{CPLEX_FOLDER}/get_cuts'\n"
                        f"Please compile this executable by typing 'make' in directory {CPLEX_FOLDER}.")
    # (async) save gurobi mip model mps for each unverified labels and solve with cplex
    manager = multiprocessing.Manager()
    self.processes = manager.dict()
    intermediate_bounds = {}
    for name, layer in self.net._modules.items():
        layer_lower = layer.lower.clone().cpu() if layer.is_lower_bound_current() else None
        layer_upper = layer.upper.clone().cpu() if layer.is_upper_bound_current() else None
        if layer_lower is not None or layer_upper is not None:
            intermediate_bounds[name] = [layer_lower, layer_upper]  # Save its intermediate layer bounds in a dictionary.
    mip_building_proc = multiprocessing.Process(target=construct_mip_with_model, args=(
        copy.deepcopy(self.model_ori).cpu(), x.clone().to(device='cpu'), self.input_shape,
        self.c.clone().cpu(), intermediate_bounds, True, self.processes))
    mip_building_proc.start()
    self.mip_building_proc = mip_building_proc


def enable_cuts(self: 'LiRPANet'):
    self.return_A = True
    if self.needed_A_dict is None:
        self.needed_A_dict = defaultdict(set)
    self.needed_A_dict[self.net.output_name[0]].add(self.net.input_name[0])
    for l in self.net.splittable_activations:
        self.needed_A_dict[l.inputs[0].name].add(self.net.input_name[0])


def create_cutter(self: 'LiRPANet', A, x):
    cut_args = arguments.Config["bab"]["cut"]
    self.cutter = Cutter(
        self, A, x, number_cuts=cut_args["number_cuts"],
        device=self.net.device)
    if cut_args["cplex_cuts"] and self.mip_building_proc is None:
        self.create_mip_building_proc(x)


def set_cut_params(self: 'LiRPANet', batch_size, batch_base, split_history):
    cut_iteration = arguments.Config["bab"]["cut"]["bab_iteration"]

    num_constrs = self.net.cut_module.cut_bias.size(0)
    iteration = arguments.Config["solver"]["beta-crown"]["iteration"]
    # Change the number of iterations during cuts.
    iteration = cut_iteration if cut_iteration > 0 else iteration

    # each general_beta: 2 (lA, uA), spec (out_c, out_h, out_w), batch, num_cuts
    general_beta = self.cutter.beta_init * torch.ones((2, 1, batch_size, num_constrs), device=self.net.device)
    if split_history is not None:
        # general beta warm up
        for batch_sh, sh in enumerate(split_history):
            if "general_betas" in sh and sh["cut_timestamp"] == self.net.cut_timestamp:
                if sh["general_betas"].shape[-1] == num_constrs:
                    # It only happens when using cplex cuts, the cuts are added before the
                    # bound computation, so that batch_base = len(split_history), we want to set the
                    # general beta for each batch.
                    assert batch_base == len(split_history)
                    general_beta[:, :, batch_sh: batch_sh+1, :] = sh["general_betas"].detach().clone()
                    general_beta[:, :, batch_sh+batch_base: batch_sh+batch_base+1, :] = sh["general_betas"].detach().clone()

    general_beta = general_beta.detach()
    general_beta.requires_grad = True
    general_betas = {self.net.final_name: general_beta}
    self.net.cut_beta_params = [general_betas[self.net.final_name]]
    for m in self.net.splittable_activations:
        m.cut_module = self.net.cut_module
        m.cut_used = True
    self.net.cut_module.general_beta = general_betas
    self.net.cut_module.cut_timestamps = [self.net.cut_timestamp for _ in range(batch_size)]
    print('cut re-enabled after branching node selection')

    return iteration


def set_cut_new_split_history(self: 'LiRPANet', new_split_history, batch_size):
    for i in range(batch_size):
        new_split_history[i]["general_betas"] = self.net.cut_module.general_beta[self.net.final_name][:, :, i:i + 1, :].detach()
        new_split_history[i]["cut_timestamp"] = self.net.cut_module.cut_timestamps[i]


def disable_cut_for_branching(self: 'LiRPANet'):
    """Disable cut_used for branching node selection.
    Reenable when beta is True.
    """
    print('cut disabled for branching node selection')
    self.net.cut_used = False
    for m in self.net.splittable_activations:
        m.cut_used = False
    self.net.cut_beta_params = []
